---
title: 'JS基础'
createdAt: '2023-05-14'
publishedAt: '2023-05-14'
updatedAt: '2023-05-14'
draft: true
summary: 'JS 常见的面试知识点'
tags: ['面试']
---

## 作用域

JavaScript 的作用域（Scope）是指在程序中定义变量的区域，决定了变量的可访问性和生命周期。了解 JavaScript 的作用域对于理解变量的可见性和作用范围至关重要。

在 JavaScript 中，有三种类型的作用域：

1. 全局作用域（Global Scope）：全局作用域是在代码中没有包裹在任何函数内的部分。在全局作用域中声明的变量和函数可以在整个代码中被访问。

2. 函数作用域（Function Scope）：函数作用域是指在函数内部声明的变量的作用范围。在函数作用域中声明的变量只能在函数内部访问，函数外部无法访问。

3. 块级作用域（Block Scope）：块级作用域是指由花括号 `{}` 包裹的代码块内部声明的变量的作用范围。在 ES6 引入 `let` 和 `const` 关键字之前，JavaScript 中没有块级作用域，只有函数作用域和全局作用域。

在 JavaScript 中，作用域是由变量声明的位置决定的。当在代码中引用一个变量时，JavaScript 引擎会根据作用域链来查找该变量的值，依次从内层作用域向外层作用域查找，直到找到变量或抵达全局作用域。

ES6 引入的 `let` 和 `const` 关键字引入了块级作用域。使用 `let` 声明的变量和使用 `const` 声明的常量将受限于最近的包含块中（例如，`if`、`for`、`while` 等）。

例如，以下是 JavaScript 中作用域的示例：

```js
// 全局作用域
const globalVariable = 'Global';

function foo() {
  // 函数作用域
  const functionVariable = 'Function';

  if (true) {
    // 块级作用域
    const blockVariable = 'Block';
    console.log(blockVariable); // 输出 'Block'
  }

  console.log(functionVariable); // 输出 'Function'
  console.log(globalVariable); // 输出 'Global'
}

foo();
console.log(globalVariable); // 输出 'Global'
```

需要注意的是，变量的作用域是在定义时确定的，而不是在运行时确定的。同时，避免变量名冲突和合理使用作用域可以提高代码的可读性和维护性。

## 闭包

闭包（Closure）是指在 JavaScript 中，内部函数（嵌套函数）可以访问其外部函数的变量和参数，即使外部函数已经执行完毕，这种现象称为闭包。

闭包是 JavaScript 中强大而重要的概念，它允许函数访问定义时的词法环境，即使函数在其词法作用域之外执行。闭包使得函数可以"记住"并访问其创建时的作用域，即使创建它的上下文已经销毁。

闭包的形成有两个要素：

1. 内部函数：在外部函数内部定义的函数，具有访问外部函数作用域中变量和参数的能力。

2. 外部函数的调用：必须通过调用外部函数来创建闭包，将内部函数作为返回值返回或传递给其他函数。

下面是一个闭包的简单示例：

```js
function outerFunction() {
  const outerVariable = 'Outer';

  function innerFunction() {
    console.log(outerVariable); // 内部函数访问外部函数的变量
  }

  return innerFunction; // 返回内部函数
}

const closure = outerFunction(); // 调用外部函数创建闭包

closure(); // 输出 'Outer'
```

在上面的例子中，内部函数 `innerFunction` 可以访问外部函数 `outerFunction` 的变量 `outerVariable`，即使 `outerFunction` 已经执行完毕并返回了。这就是闭包的特性。

闭包的应用场景包括：

1. 封装私有变量：通过闭包可以创建私有变量，只能通过内部函数访问，从而实现模块化和信息隐藏。

2. 记忆状态：通过闭包可以在函数调用之间保持状态，并且该状态在每次调用函数时保持一致。

3. 延迟执行：通过闭包可以实现延迟执行函数，例如使用定时器或事件监听器。

需要注意的是，过度使用闭包可能会导致内存泄漏，因为闭包会保持对外部函数作用域的引用，导致内存无法释放。因此，在使用闭包时要注意管理内存，并避免不必要的闭包引用。

闭包是 JavaScript 中一项强大的功能，合理地使用闭包可以提高代码的灵活性和可复用性，但也需要注意适度使用以及注意内存管理。

## 原型链

原型链（Prototype Chain）是 JavaScript 中用于实现继承和属性查找的机制。每个对象都有一个内部链接（[[Prototype]] 或 `__proto__`），指向其原型对象（Prototype Object），原型对象也可以拥有自己的原型对象，形成一条原型链。

当我们访问一个对象的属性或方法时，JavaScript 引擎会首先在对象自身查找，如果找不到，则会沿着原型链向上查找，直到找到该属性或方法或抵达原型链的顶端（即 `Object.prototype`）。

下面是原型链的一个简单示例：

```javascript
// 定义一个构造函数
function Person(name) {
  this.name = name;
}

// 在构造函数的原型对象上定义方法
Person.prototype.greet = function() {
  console.log('Hello, ' + this.name);
};

// 创建一个实例对象
var person = new Person('John');

// 访问实例对象的属性和方法
console.log(person.name); // 输出 'John'
person.greet(); // 输出 'Hello, John'
```

在上面的例子中，`Person` 是一个构造函数，我们通过 `new Person('John')` 创建了一个实例对象 `person`。`person` 对象继承了 `Person` 构造函数的原型对象上的属性和方法，包括 `name` 属性和 `greet` 方法。当我们访问 `person.name` 和 `person.greet()` 时，JavaScript 引擎会首先在 `person` 对象上查找对应的属性和方法，如果找不到，则会继续在原型链上查找。

如果在原型链上找不到所需的属性或方法，最终会抵达原型链的顶端，也就是 `Object.prototype`。`Object.prototype` 是所有对象的最顶层原型，它包含一些通用的方法，例如 `toString()` 和 `valueOf()`。

需要注意的是，每个对象都有自己的原型链，但原型链是共享的。也就是说，如果在原型对象上进行修改，所有基于该原型对象创建的实例都会受到影响。

原型链的概念是实现继承的基础，它使得对象可以从其他对象继承属性和方法。在 JavaScript 中，原型链是一种灵活而强大的机制，可以帮助我们构建可复用的对象和实现面向对象的编程范式。

## 上下文

上下文（Context）在编程中是一个常用的概念，它可以指代不同的含义，具体取决于上下文所使用的语境。在 JavaScript 中，上下文通常涉及到函数的执行环境以及函数内部的 `this` 值。

1. 函数执行上下文（Function Execution Context）：在 JavaScript 中，每当函数被调用执行时，都会创建一个函数执行上下文。函数执行上下文包含了函数执行所需的一些信息，例如函数的变量、参数、作用域链等。每个函数执行上下文都是独立的，并且可以形成一个调用栈（Call Stack）。

2. `this` 上下文：`this` 关键字在函数执行时引用当前函数的上下文对象。`this` 的值根据函数的调用方式动态确定，它指向调用函数的对象或指向全局对象（在非严格模式下）。

3. 对象字面量上下文：当使用对象字面量创建对象时，其中的方法会继承对象字面量的上下文。这意味着在方法内部，`this` 将指向对象本身。

4. 事件处理上下文：当在浏览器中处理事件时，事件处理函数的上下文将是触发事件的元素。

需要注意的是，上下文是动态的，并且在函数执行时确定。同一个函数在不同的调用上下文中可能会有不同的行为。

以下是一些示例来说明上下文的概念：

```javascript
// 示例 1: 函数执行上下文
function foo() {
  var name = 'John';
  console.log(name); // 输出 'John'
}

foo();

// 示例 2: `this` 上下文
var obj = {
  name: 'John',
  greet: function() {
    console.log('Hello, ' + this.name);
  }
};

obj.greet(); // 输出 'Hello, John'

// 示例 3: 对象字面量上下文
var person = {
  name: 'John',
  sayName: function() {
    console.log('My name is ' + this.name);
  }
};

person.sayName(); // 输出 'My name is John'

// 示例 4: 事件处理上下文
var button = document.querySelector('#myButton');
button.addEventListener('click', function() {
  console.log('Button clicked');
  console.log(this); // 输出触发事件的按钮元素
});
```

了解上下文的概念对于理解 JavaScript 中的作用域、`this` 的用法以及事件处理等方面都非常重要。通过正确理解和使用上下文，可以编写出更加灵活和高效的 JavaScript 代码。

## 继承

继承是面向对象编程中的一个重要概念，它允许一个对象（称为子类或派生类）从另一个对象（称为父类或基类）继承属性和方法。通过继承，子类可以拥有父类的特性，并且可以扩展或修改这些特性，同时也可以定义自己独有的属性和方法。

在 JavaScript 中，有多种实现继承的方式：

1. 原型链继承：使用原型链实现继承是 JavaScript 中最常见的方式。通过将子类的原型对象指向父类的实例，使得子类能够继承父类的属性和方法。这种方式实现的继承存在一些问题，如原型对象共享、无法向父类传递参数等。

2. 构造函数继承：通过在子类的构造函数中调用父类的构造函数来实现继承。这种方式使子类可以继承父类的属性，并且可以传递参数给父类的构造函数。但是，这种方式无法继承父类原型对象上的方法。

3. 组合继承：组合继承是将原型链继承和构造函数继承结合起来的一种方式。它通过使用原型链继承父类的原型对象，并在子类的构造函数中调用父类的构造函数，同时也能继承父类的属性和方法，并解决了原型对象共享的问题。

4. 原型式继承：通过使用一个中间对象作为桥梁，实现对父类对象的浅拷贝，从而创建一个新的对象作为子类。这种方式类似于对象的克隆，但是无法继承父类的方法。

5. 寄生式继承：寄生式继承是在原型式继承的基础上进行扩展，它在创建子类对象时增加了一些额外的属性和方法，从而实现对父类对象的增强。

6. ES6 类继承：ES6 引入了 `class` 关键字，提供了更简洁和易于理解的方式来实现继承。通过 `extends` 关键字，可以从一个类派生出另一个类，并使用 `super` 关键字调用父类的构造函数和方法。

以下是一个使用原型链继承的简单示例：

```javascript
// 父类
function Animal(name) {
  this.name = name;
}

Animal.prototype.greet = function() {
  console.log('Hello, I am ' + this.name);
};

// 子类
function Dog(name) {
  this.name = name;
}

Dog.prototype = new Animal(); // 继承父类的原型对象

Dog.prototype.bark = function() {

## 缓存

HTTP缓存是一种在客户端和服务器之间缓存资源的机制，可以减少网络请求的次数，提高性能和响应速度。当客户端请求资源时，服务器可以返回一个缓存标识（例如ETag或Last-Modified），客户端可以在后续的请求中使用该标识来判断资源是否已被修改，并决定是否从缓存中获取资源。

HTTP缓存有以下几种常见的策略和机制：

1. 强缓存（Expires / Cache-Control）：服务器在响应头中设置`Expires`或`Cache-Control`字段来指示资源的缓存过期时间。客户端可以在下一次请求时，检查缓存的过期时间，如果资源未过期，则直接从缓存中获取资源，而无需向服务器发送请求。

   - `Expires`：指定资源的绝对过期时间，是一个具体的日期时间，由服务器返回给客户端。但是，Expires使用的是服务器的时间，如果客户端和服务器的时间不一致，可能会导致缓存失效。
   
   - `Cache-Control`：提供了更灵活的缓存控制方式，常见的指令包括：
     - `max-age`：指定资源的相对过期时间，以秒为单位。
     - `no-cache`：客户端在使用缓存资源之前，需要与服务器确认资源是否发生了变化。
     - `no-store`：禁止缓存，每次请求都要向服务器发送请求。

2. 协商缓存（ETag / Last-Modified）：服务器在响应头中返回资源的唯一标识，例如`ETag`或`Last-Modified`。客户端在后续的请求中，通过`If-None-Match`或`If-Modified-Since`字段将这些标识发送给服务器，服务器根据标识判断资源是否发生了变化。如果资源未发生变化，则返回`304 Not Modified`状态码，客户端可以直接从缓存中获取资源。

   - `ETag`：是一个由服务器生成的唯一标识符，通常是资源内容的哈希值。客户端在后续的请求中，通过`If-None-Match`字段将该标识发送给服务器。
   
   - `Last-Modified`：指示资源的最后修改时间，由服务器返回给客户端。客户端在后续的请求中，通过`If-Modified-Since`字段将该时间发送给服务器。

3. 缓存控制响应头：除了上述的缓存机制，服务器还可以使用其他响应头字段来控制缓存行为，例如：
   - `Cache-Control`：可以通过指定`no-store`禁止缓存，或者使用`no-cache`要求客户端验证缓存的有效性。
   - `Pragma`：通常用于向后兼容HTTP/1.0，指定`no-cache`要求客户端验证缓存

## 函数式编程

函数式编程（Functional Programming）是一种编程范式，它将计算视为函数求值的过程，强调使用纯函数（Pure Function）和避免改变状态和可变数据。函数式编程主要关注问题的"是什么"而不是"如何"，通过将问题划分为一系列的函数，通过函数的组合和转换来解决问题。

函数式编程的一些核心概念和特点包括：

1. 纯函数（Pure Function）：纯函数是指没有副作用（Side Effect）并且对于相同的输入总是返回相同的输出的函数。纯函数不依赖于外部状态，只通过输入参数进行计算。由于纯函数的结果仅由输入决定，因此它们更容易进行测试和推理，并且能够提供更好的可靠性和可维护性。

2. 不可变性（Immutability）：函数式编程倾向于使用不可变数据，即数据一旦创建就不能被修改。在函数式编程中，不可变数据被认为是更安全和更容易理解的，因为它们不会发生意外的修改。当需要修改数据时，函数式编程通常会创建一个新的数据副本，而不是直接修改原始数据。

3. 高阶函数（Higher-Order Functions）：函数式编程鼓励使用高阶函数，即函数可以接受其他函数作为参数或返回函数作为结果。高阶函数可以用于实现抽象和组合，提高代码的可重用性和灵活性。

4. 函数组合（Function Composition）：函数式编程强调通过函数的组合来解决问题。函数可以作为参数传递给其他函数，也可以将多个函数组合成一个新的函数。函数组合能够简化代码并提高可读性，同时还可以避免中间变量和副作用。

5. 延迟计算（Lazy Evaluation）：函数式编程支持延迟计算，即仅在需要时计算结果，而不是立即计算。这种方式可以提高性能和资源利用率，特别是在处理大规模数据集或无限序列时。

函数式编程在编写高效、可维护和可测试的代码方面具有许多优势，它提供了一种不同的思考方式和工具集，使得代码更具表达力和抽象性。它在许多编程语言中都有广泛的应用，例如 JavaScript、Python、Haskell 等。

## 输入域名到页面渲染

将域名输入到浏览器地址栏并按下回车后，从输入域名到页面渲染的整个过程可以概括为以下几个步骤：

1. DNS解析：浏览器首先将输入的域名发送到本地的DNS解析器，解析器会查询域名对应的IP地址。如果解析器缓存了该域名的IP地址，则直接返回，否则将向上级DNS服务器发起查询，直到找到域名对应的IP地址。

2. TCP连接：一旦获得了目标服务器的IP地址，浏览器会通过TCP/IP协议与服务器建立TCP连接。这涉及到通过三次握手建立可靠的连接，确保客户端和服务器之间的数据传输可靠性。

3. 发起HTTP请求：建立TCP连接后，浏览器会发送一个HTTP请求到服务器。请求中包括请求方法（GET、POST等）、URL、请求头（包括一些元数据信息，如User-Agent、Cookie等）以及可选的请求体（如POST请求中的表单数据）。

4. 服务器处理请求：服务器收到HTTP请求后，根据请求的URL和方法，处理请求并生成一个HTTP响应。处理可能包括读取数据库、执行业务逻辑等操作。服务器生成的响应包括状态码（如200表示成功、404表示未找到等）、响应头（包含响应的元数据信息，如Content-Type、Content-Length等）以及可选的响应体（如服务器返回的HTML内容）。

5. 接收响应：一旦服务器生成了响应，通过TCP连接将响应发送回客户端。客户端接收到响应后，根据响应内容进行处理。处理可以包括解析响应头、读取响应体中的数据等。

6. 页面渲染：当浏览器接收到服务器响应中的HTML内容后，它会开始解析HTML文档，并构建DOM树和CSSOM树。解析过程中，如果遇到外部资源（如样式表、JavaScript文件、图像等），浏览器会发起额外的请求获取这些资源。

7. 资源加载：浏览器会根据HTML文档中的资源链接发起相应的请求，获取所需的资源文件。这些资源包括CSS文件、JavaScript文件、图像等。浏览器会按照资源的优先级和并发限制来进行资源的加载。

8. 页面渲染：一旦浏览器获取到所需的资源文件，它会根据DOM树、CSSOM树和JavaScript脚本来进行页面渲染。渲染过程包括布局计算、绘制元素、应用样式等。最终，浏览器将渲染好的页面显示给用户。

需要注意的是，上述过程是一个

## 事件循环

事件循环（Event Loop）是 JavaScript 运行时环境中用于处理异步操作的一种机制。它负责管理执行任务队列（Task Queue）中的任务，并将它们逐个执行。

事件循环的主要目的是保证 JavaScript 单线程的特性，即同一时间只能执行一个任务，而不会被阻塞。当 JavaScript 执行到一个异步操作时，比如定时器、网络请求或事件监听器，它会将该操作交给对应的异步 API，并注册一个回调函数。异步操作完成后，将回调函数放入任务队列中，等待事件循环将其执行。

下面是事件循环的基本流程：

1. 执行同步任务：从调用栈（Call Stack）中取出位于顶部的同步任务，按照顺序执行。

2. 处理微任务：检查微任务队列（Microtask Queue）是否有任务，如果有，则依次执行所有微任务。微任务通常包括 Promise 的回调函数、MutationObserver 和 Object.observe 的回调等。

3. 渲染：如果浏览器环境中存在需要执行的渲染任务，比如重绘或回流，会执行相应的渲染操作。

4. 执行宏任务：检查任务队列（Task Queue）中是否有任务，如果有，则取出队列中的一个任务进行执行。宏任务包括定时器回调函数、UI 交互事件回调等。

5. 重复上述步骤：重复执行上述步骤，直到调用栈和任务队列都为空。

需要注意的是，事件循环并不是一次性地将所有的任务执行完毕，而是按照上述的流程循环执行。它保证了异步任务的执行顺序和同步任务的优先级。

另外，微任务比宏任务具有更高的优先级，每次执行完一个宏任务后，会立即处理所有微任务，而不会等待下一个宏任务开始。这也是为什么 Promise 的回调函数比定时器回调函数先执行的原因。

事件循环的理解对于处理 JavaScript 中的异步操作非常重要，它有助于避免阻塞代码并实现高效的异步编程。

## 事件委托

事件委托（Event delegation）是一种常见的前端开发技术，用于处理动态生成的元素或大量相似元素的事件监听。通过将事件监听器绑定到它们的共同父元素，而不是每个子元素上，来简化事件管理。

使用事件委托的好处包括：

1. 减少内存占用：通过将事件监听器绑定到父元素而不是每个子元素，可以节省内存，特别是在处理大量元素的情况下。

2. 动态元素支持：对于动态生成的元素，事件委托可以自动处理它们的事件，而无需手动为每个元素添加事件监听器。

3. 简化事件管理：通过将事件监听器绑定到共同的父元素，可以简化事件管理。当需要添加、删除或更改事件时，只需操作父元素，而不必单独处理每个子元素。

使用事件委托的步骤如下：

1. 找到共同的父元素：确定要委托事件的共同父元素。这通常是包含动态元素的静态元素。

2. 绑定事件监听器：将事件监听器绑定到共同的父元素上，使用适当的事件类型（如click、mouseover等）。

3. 判断事件源：在事件处理程序中，通过事件对象（event object）的属性，如`event.target`，判断实际触发事件的子元素。

4. 执行相应操作：根据判断的事件源，执行相应的操作或处理逻辑。

例如，如果有一个ul元素包含多个li元素，需要为每个li元素添加点击事件监听器，可以使用事件委托来简化：

```js
// 步骤1：找到共同的父元素
const parentElement = document.querySelector('ul');

// 步骤2：绑定事件监听器
parentElement.addEventListener('click', function(event) {
  // 步骤3：判断事件源
  if (event.target.tagName === 'LI') {
    // 步骤4：执行相应操作
    console.log('Clicked on li:', event.target.textContent);
  }
});
```

通过将点击事件监听器绑定到ul元素上，无论动态添加或删除li元素，都会自动触发相应的操作，无需为每个li元素单独添加事件监听器。

这样，事件委托可以简化代码，并提供更好的性能和可维护性，特别适用于需要处理大量相似元素或动态生成元素的情况。